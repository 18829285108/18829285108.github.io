<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Kingvirre">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Kingvirre">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kingvirre">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Kingvirre</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kingvirre</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人生自是有情始，此事不关风与月</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/09/2019总结，2020规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/09/2019总结，2020规划/" itemprop="url">2019总结，2020规划--学习至上</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-09T18:10:10+08:00">
                2020-01-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="回首2019"><a href="#回首2019" class="headerlink" title="回首2019"></a>回首2019</h3><p>2019年，过的好快，真的是弹指一瞬间，这一年，立了很多flag，在年终的时候，也不敢去想年初的目标，毕竟有很多没有实现！！！<br>第一个就是考研，和高中好友相约一起考在职研，买了一堆书，过年还在胖腾家里读英语，看专业课资料，但是热度也仅局限于假期几天。<br>说是工作忙，其实还是自己懒惰。10月报名的时候，纠结了半天也没报名，不想死的太惨。</p>
<p>&emsp; &#8195;1月，元旦在平遥举行了典礼，见了很多几年未见的亲朋好友，感谢，至此结婚仪式流程全部走完，开始踏实过小日子了。公司绩效考核还算满意，给2018划上圆满句号。</p>
<p>&emsp; &#8195;2月，过完新年，休婚假，开启马尔代夫+迪拜蜜月游，花掉5w大洋，有点心疼，不过还是觉得很值。立下2019攒钱规划，攒够多少钱，还多少贷款。开心的是2019攒钱的目标顺利完成，<br>年中收湖居房子的时候也按照预期，把中南贷款还了一部分。</p>
<p>&emsp; &#8195;3月，平平常常，没有学习什么新知识。每个月都会想起来，要学习，要更新博客，但是只是想了想，都没有坚持下来。</p>
<p>&emsp; &#8195;4月，只是简单生活，自驾去昌平摘草莓，去百里画廊和温都水城欣赏风景，兜兜转转去了解北京，努力想让日子丰富一些。</p>
<p>&emsp; &#8195;5月，劳动节放假4天，去了上海。和胖腾姐姐姐夫团聚，去旅行的同时，开始想着去逛博物馆，了解历史，这点得感谢胖腾，让我们的旅行更有意义</p>
<p>&emsp; &#8195;6月，嘟嘟小外甥出生了，家里喜添新成员。我也开始去北医三院看牙，把门牙做了处理，花了1w多，但是感觉还是很值，起码可以当众笑了。遗憾的事情，是因为治疗牙齿吃止疼药<br>错过了更重要的东西，但是我相信还会有的，可能到那个时候，我也才会有足够的勇气去迎接。6月底去西安收房，自己名下的房子还是不一样的感觉，顺便带妈妈去体检。</p>
<p>&emsp; &#8195;7月，回了趟平遥，见爸妈，参加康哥帅帅婚礼，看了又见平遥。年中了，我都没有仔细思考我工作中的学习和需要进步的地方，现在想起来真是惭愧。</p>
<p>&emsp; &#8195;8月，赴闺蜜之约，杭州游。虽然许久未见，再次相见仍感亲切。</p>
<p>&emsp; &#8195;9月，领证一周年，去了阿那亚，离北京很近，以后有机会可以常去，很让人放松的地方。中秋节自驾去了大同，顺便参观了云冈石窟，爬了恒山悬空寺，古人的智慧让人佩服。</p>
<p>&emsp; &#8195;10月，国庆回韩城，去西安办理了湖居手续，开始想着换租的地方，想过自己的小日子，不想再合租了。国庆后，胖腾换了工作，比之前更忙碌了，但是待遇高了，而且离家近了。<br>整体还是为胖腾开心。</p>
<p>&emsp; &#8195;11月，房子定下来了，一月7300，但是住的真的舒心，生活品质上升了好几个台阶，感觉钱花的真值，而且和胖腾达成一致，要想怎么赚钱，而不是怎么省钱。<br>这个月过了25周岁生日，拍了古装写真送给自己，还是很开心的。给妈妈买的保险，到期后继续续约。工作上，服务端测试缺人，紧急拉过去支持了一把，学了很多知识，压力也比平时大好多，同时也意识到自己专业能力的缺陷，<br>进步空间还是很大的。</p>
<p>&emsp; &#8195;12月，这个月在生活技能上有了显著进步，在同事的指导下，开始学做饭，自己可以做点小菜，琢磨怎么去做好吃的饭了。公司年会，什么奖品也没抽到，和胖腾一个运气。<br>一到年底，就又开始懊恼了，懊恼自己怎么没有多学一些专业知识，每天在业务中奔波，所以在迈入2020年后，我一定要好好规划自己的学习、生活计划。</p>
<p>2019年，有满足也有不足，有喜悦也有悲伤，已经过去的时光都会留存在记忆中。最幸福的事情是金钱方面没有怎么操心，有条不紊的进行。<br>最正常的事情，是享受生活，什么时候都不会忘记，所以这点不必担心。最失望的事情是，工作中的挑战和专业知识的充电，意识到不足，继续加油吧！<br>继续向未知的方向，发起挑战，加油喽！！</p>
<h3 id="2020规划"><a href="#2020规划" class="headerlink" title="2020规划"></a>2020规划</h3><p>&emsp; &#8195; 2020如约而至，来的太快，没空感叹，只想着抓紧把目标定下来，开启新一年计划。</p>
<ul>
<li><p>专业和工作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1，学习测试专栏，每天两节课</span><br><span class="line">2，学习java，每天两节课</span><br><span class="line">3，学习hive+sql，定期总结文档</span><br><span class="line">4，保持博客每周都有更新</span><br></pre></td></tr></table></figure>
</li>
<li><p>生活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1，定期攒钱，还完中南贷款</span><br><span class="line">2，旅行，出一次国，国内有假期就出去玩。</span><br><span class="line">3，坚持做饭，学习做饭，做几道拿手菜</span><br><span class="line">4，保持对生活的热爱</span><br><span class="line">5，随时准备着，应对生活的突然事件。</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/python闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/python闭包/" itemprop="url">python闭包</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-17T20:17:59+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="python-闭包"><a href="#python-闭包" class="headerlink" title="python 闭包"></a>python 闭包</h2><p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/前端测试——ios客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/前端测试——ios客户端/" itemprop="url">前端测试——ios客户端</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-25T10:33:38+08:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/java基础概念一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/java基础概念一/" itemprop="url">java基础概念一</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-11T11:24:01+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ol>
<li>对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有三大好处：<ul>
<li>良好的封装能够减少耦合。</li>
<li>类内部的结构可以自由修改。</li>
<li>可以对成员进行更精确的控制。</li>
<li>隐藏信息，实现细节。</li>
</ul>
</li>
<li>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界访问，我们大可不必提供方法给外界访问。<br>但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义。比如我们将一个房子看做是一个对象，里面的漂亮的装饰，如沙发、电视剧等等都是该房子的私有属性，<br>但是如果我们没有那些墙遮挡，别人就会一览无余，没有一点儿隐私！就是存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到其他的。<br>但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</li>
<li>继承的属性<ul>
<li>子类拥有父类非private的属性和方法。（private的属性和方法继承不了）</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li>对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。<br>对于继承而言，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事</li>
<li>对于protected而言，它指明就类用户而言，他是private，但是对于任何继承此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</li>
</ol>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol>
<li>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，<br>这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/04/java是怎么运行起来的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/04/java是怎么运行起来的/" itemprop="url">java是怎么运行起来的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-04T14:46:25+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java初学习"><a href="#java初学习" class="headerlink" title="java初学习"></a>java初学习</h2><h2 id="jvm-是什么"><a href="#jvm-是什么" class="headerlink" title="jvm 是什么"></a>jvm 是什么</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ol>
<li>Java Virtual Machine（Java虚拟机）。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。<br>一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。<br>而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。<br>Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。<br><font color="#dd0000">Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。</font><br></li>
<li>Java虚拟机由于字节码定义的限制似乎只能运行于32位地址空间的机器上。但是可以创建一个Java虚拟机，它自动地把字节码转换成64位的形式。<br>从Java虚拟机支持的数据类型可以看出，Java对数据类型的内部格式进行了严格规定，这样使得各种Java虚拟机的实现对数据的解释是相同的，从而保证了Java的与平台无关性和可移植性。</li>
<li>JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：JVM指令系统、JVM寄存器、JVM 栈结构、JVM 碎片回收堆、JVM 存储区</li>
<li>JVM是java的核心和基础，在java编译器和os平台之间的虚拟处理器。它是一种基于下层的操作系统和硬件平台并利用软件方法来实现的抽象的计算机，可以在上面执行java的字节码程序。</li>
</ol>
<h3 id="JVM运行原理"><a href="#JVM运行原理" class="headerlink" title="JVM运行原理"></a>JVM运行原理</h3><ol>
<li><p>JVM运行原理<br>java编译器只需面向JVM，生成JVM能理解的代码或字节码文件。Java源文件经编译器，编译成字节码程序，通过JVM将每一条指令翻译成不同平台机器码，通过特定平台运行。<br>JVM执行程序的过程 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I.加载.class文件</span><br><span class="line">II.管理并分配内存</span><br><span class="line">III.执行垃圾收集</span><br></pre></td></tr></table></figure>
</li>
<li><p>JRE（java运行时环境）包含JVM的java程序的运行环境<br>JVM是Java程序运行的容器,但是他同时也是操作系统的一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间。<br>JVM在整个jdk中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也叫虚拟计算机.<br>操作系统装入JVM是通过jdk中Java.exe来完成,通过下面4步来完成JVM环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.创建JVM装载环境和配置</span><br><span class="line">b.装载JVM.dll</span><br><span class="line">c.初始化JVM.dll并挂接到JNIENV(JNI调用接口)实例</span><br><span class="line">d.调用JNIEnv实例装载并处理class类。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><ol>
<li><p>JDK（Java Development Kit）是整个Java的核心，包括了Java运行环境JRE、Java工具和Java基础类库。<br>Java Runtime Environment（JRE）是运行JAVA程序所必须的环境的集合，包含JVM标准实现及Java核心类库。<br>JVM是Java Virtual Machine（Java虚拟机）的缩写，是整个java实现跨平台的最核心的部分，能够运行以Java语言写作的软件程序。</p>
</li>
<li><p>JDK=JRE+JVM+其它，运行Java程序一般都要求用户的电脑安装JRE环境；没有jre，java程序无法运行；而没有java程序，jre就没有用武之地。</p>
</li>
<li>JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，<br>而jvm和lib和起来就称为jre。</li>
</ol>
<h2 id="java程序是怎么运行起来的"><a href="#java程序是怎么运行起来的" class="headerlink" title="java程序是怎么运行起来的"></a>java程序是怎么运行起来的</h2><ol>
<li>jvm先将java文件编译成class文件<br>class文件结构包括：1.魔数 2.Java版本 3.常量池  4.本类 5.父类 6.接口  7.字段 8 方法 9属性 10识别标志</li>
<li><p>Java命令执行程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  2.1 java.c 创建执行环境, 先寻找jre路径, java.dll负责</span><br><span class="line">  2.2 加载jvm，执行jvm.dll（windows）, 创建jvm环境</span><br><span class="line">  2.3 设置初始化Java运行参数</span><br><span class="line">  2.4 创建线程初始化jvm并执行Java程序, 我们写的main方法</span><br></pre></td></tr></table></figure>
</li>
<li><p>JVM如何执行Java程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> a. 加载class文件</span><br><span class="line">b. 验证</span><br><span class="line">c. 为静态变量常量等分配内存初始化值</span><br><span class="line">d. 解析文件</span><br><span class="line">e. 初始化。执行类构造器静态类。代码块的执行</span><br><span class="line">f. 找到main方法执行指令，执行Java程序。</span><br></pre></td></tr></table></figure>
</li>
<li><p>java程序执行的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Step1:将字节码加入内存；</span><br><span class="line">Step2:对字节码进行合法性检查；</span><br><span class="line">Step3:jvm会为每个字节码文件都生成一个对象(class)；</span><br><span class="line">Step4:执行静态代码块，初始化静态成员等；</span><br><span class="line">Step5:执行入口函数main方法；</span><br><span class="line">注意：实例块和静态块，可以对java对象进行初始化操作，和构造器非常类似</span><br><span class="line">静态块先于main方法执行，实例块先于构造方法执行</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/28/软件测试6——测试覆盖率/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/软件测试6——测试覆盖率/" itemprop="url">软件测试6——测试覆盖率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-28T18:00:55+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h1><p>测试覆盖率通常被用来衡量测试的充分性和完整性，从广义的角度来讲，测试覆盖率主要分为两大类，一类是面向项目的需求覆盖率，另一类是更偏向技术的代码覆盖率。</p>
<h2 id="需求覆盖率"><a href="#需求覆盖率" class="headerlink" title="需求覆盖率"></a>需求覆盖率</h2><ol>
<li>需求覆盖率是指测试对需求的覆盖程度，通常的做法是将每一条分解后的软件需求和对应的测试建立一对多的映射关系，最终目标是保证测试可以覆盖每个需求，以保证软件产品的质量。</li>
<li>通常采用 ALM，Doors 和 TestLink 等需求管理工具来建立需求和测试的对应关系，并以此计算测试覆盖率。</li>
<li>互联网测试项目中很少直接基于需求来衡量测试覆盖率，而是将软件需求转换成测试需求，然后基于测试需求再来设计测试点。</li>
<li>现在人们口中的测试覆盖率，通常默认指代码覆盖率，而不是需求覆盖率。</li>
</ol>
<h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率是指，至少被执行了一次的条目数占整个条目数的百分比。<br>如果“条目数”是语句，对应的就是代码行覆盖率；如果“条目数”是函数，对应的就是函数覆盖率；如果“条目数”是路径，那么对应的就是路径覆盖率。</p>
<ul>
<li>行覆盖率又称为语句覆盖率，指已经被执行到的语句占总可执行语句（不包含类似 C++ 的头文件声明、代码注释、空行等等）的百分比。这是最常用也是要求最低的覆盖率指标。</li>
<li>判定覆盖又称分支覆盖，用以度量程序中每一个判定的分支是否都被测试到了，即代码中每个判断的取真分支和取假分支是否各被覆盖至少各一次。比如，对于 if(a&gt;0 &amp;&amp; b&gt;0)，就要求覆盖“a&gt;0 &amp;&amp; b&gt;0”为 TURE 和 FALSE 各一次。</li>
<li>条件覆盖是指，判定中的每个条件的可能取值至少满足一次，度量判定中的每个条件的结果 TRUE 和 FALSE 是否都被测试到了。比如，对于 if(a&gt;0 &amp;&amp; b&gt;0)，就要求“a&gt;0”取 TRUE 和 FALSE 各一次，同时要求“b&gt;0”取 TRUE 和 FALSE 各一次。<br>代码覆盖率的价值</li>
</ul>
<p>统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的不可达的废弃代码。<br>随着代码覆盖率的提高，付出的代价越来越大， 因为在后期，需要大量的桩代码、Mock 代码和全局变量的配合来控制执行路径。<br>一般，只有单元测试阶段对代码覆盖率有较高的要求。因为从技术实现上讲，单元测试可以最大化地利用打桩技术来提高覆盖率。</p>
<h3 id="代码覆盖率的局限性"><a href="#代码覆盖率的局限性" class="headerlink" title="代码覆盖率的局限性"></a>代码覆盖率的局限性</h3><ol>
<li><p>即使设计的测试用例已经达到 100% 的代码覆盖率，软件产品的质量也做不到万无一失。根本原因是代码覆盖率的计算是基于现有代码，并不能发现那些“未考虑某些输入”以及“未处理某些情况”形成的缺陷。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举个极端的例子，如果一个被测函数里面只有一行代码，只要这个函数被调用过了，那么衡量这一行代码质量的所有覆盖率指标都会是 100%，但是这个函数是否真正实现了应该需要实现的功能呢？</span><br><span class="line">代码覆盖率反映的仅仅是已有代码的哪些逻辑被执行过了，哪些逻辑还没有被执行过。以此为依据补充测试用例，可以去测试那些还没有覆盖到的执行路径。但也是仅此而已，对于那些压根还没有代码实现的部分，基于代码覆盖率的统计指标就无能为力了。</span><br></pre></td></tr></table></figure>
</li>
<li><p>高的代码覆盖率不一定能保证软件的质量，但是低的代码覆盖率一定不能能保证软件的质量。</p>
</li>
</ol>
<h3 id="JAVA-代码覆盖率工具"><a href="#JAVA-代码覆盖率工具" class="headerlink" title="JAVA 代码覆盖率工具"></a>JAVA 代码覆盖率工具</h3><p>JaCoCo 是一款 Java 代码的主流开源覆盖率工具，可以很方便地嵌入到 Ant、Maven 中，并且和很多主流的持续集成工具以及代码静态检查工具，比如 Jekins 和 Sonar 等，都有很好的集成。</p>
<p><img src="/2018/07/28/软件测试6——测试覆盖率/jacoco.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如上图为JaCoCo 的整体代码覆盖率统计报告，包括了每个 Java 代码文件的行覆盖率以及分支覆盖率统计，并给出了每个 Java 代码文件的行数、方法数和类数等具体信息。</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/07/28/软件测试6——测试覆盖率/jacoco2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如上图为每个 Java 文件内部详细的代码覆盖率情况，绿色的行表示已经被覆盖，红色的行表示尚未被覆盖，黄色的行表示部分覆盖；左侧绿色菱形块表示该分支已经被完全覆盖、黄色菱形块表示该分支仅被部分覆盖。</span><br></pre></td></tr></table></figure></p>
<h3 id="代码覆盖率工具的实现原理"><a href="#代码覆盖率工具的实现原理" class="headerlink" title="代码覆盖率工具的实现原理"></a>代码覆盖率工具的实现原理</h3><ol>
<li>实现代码覆盖率的统计，最基本的方法就是注入（Instrumentation）。注入就是在被测代码中自动插入用于覆盖率统计的探针（Probe）代码，并保证插入的探针代码不会给原代码带来任何影响。</li>
<li>对于 Java 代码来讲，根据注入目标的不同，可以分为源代码（Source Code）注入和字节码（Byte Code）注入两大类。<br>基于 JVM 本身特性以及执行效率的原因，目前主流的工具基本都是使用字节码注入，注入的具体实现采用 ASM 技术。<br>ASM 是一个 Java 字节码操纵框架，能被用来动态生成类或者增强既有类的功能，可以直接产生 class 文件，也可以在类被加载入 JVM 之前动态改变类行为。</li>
<li>根据注入发生的时间点，字节码注入又可以分为两大模式：On-The-Fly 注入模式和 Offline 注入模式。</li>
</ol>
<ul>
<li><p>On-The-Fly 注入模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">On-The-Fly 模式的特点在于无需修改源代码，也无需提前进行字节码插桩。它适用于支持 Java Agent 的运行环境。</span><br><span class="line">优点是，可以在系统不停机的情况下，实时收集代码覆盖率信息。缺点是运行环境必须允许使用 Java Agent。</span><br><span class="line"></span><br><span class="line">实现 On-The-Fly 模式，主要有两种技术方案：</span><br><span class="line">开发自定义的类装载器（Class Loader）实现类装载策略，每次类加载前，需要在 class 文件中插入探针，早期的 Emma 就是使用这种方案实现的探针插入；</span><br><span class="line">借助 Java Agent，利用执行在 main() 方法之前的拦截器方法 premain() 来插入探针，实际使用过程中需要在 JVM 的启动参数中添加“-javaagent”并指定用于实时字节码注入的代理程序，</span><br><span class="line">这样代理程序在装载每个 class 文件前，先判断是否已经插入了探针，如果没有则需要将探针插入 class 文件中，目前主流的 JaCoCo 就是使用了这个方式。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Offline 注入模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Offline 模式也无需修改源代码，但是需要在测试开始之前先对文件进行插桩，并事先生成插过桩的 class 文件。它适用于不支持 Java Agent 的运行环境，以及无法使用自定义类装载器的场景。</span><br><span class="line">优点是，JVM 启动时不再需要使用 Java Agent 额外开启代理，缺点是无法实时获取代码覆盖率信息，只能在系统停机时下获取。</span><br><span class="line">Offline 模式根据 是生成新的 class 文件还是直接修改原 class 文件，又可以分为 Replace 和 Inject 两种不同模式。</span><br><span class="line"></span><br><span class="line">和 On-The-Fly 注入模式不同，Replace 和 Inject 的实现是，在测试运行前就已经通过 ASM 将探针插入了 class 文件，而在测试的运行过程中不需要任何额外的处理。Cobertura 就是使用 Offline 模式的典型代表。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>测试覆盖率通常被用来衡量测试的充分性和完整性，包括面向项目的需求覆盖率和更偏向技术的代码覆盖率。<br>但是，高的代码覆盖率不一定能保证软件的质量，因为代码覆盖率是基于现有代码，无法发现那些“未考虑某些输入”以及“未处理某些情况”形成的缺陷。</p>
<p>在实际工作中，是否还接触过 C/C++，JavaScript 等语言的代码覆盖率工具，比如 GCC Coverage、JSCoverage 和 Istanbul 等？</p>
<hr>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/10759" target="_blank" rel="noopener">https://time.geekbang.org/column/article/10759</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/21/软件测试5——自动化测试技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/21/软件测试5——自动化测试技术/" itemprop="url">软件测试5——自动化测试技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-21T21:02:37+08:00">
                2018-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>比如：GUI 自动化测试：早年的 C/S 架构，通常就是用自动化测试脚本打开被测应用，然后在界面上以自动化的方式执行一系列的操作；<br>现今的 Web 站点测试，也是用自动化测试脚本打开浏览器，然后输入要访问的网址，之后用自动化脚本识别定位页面元素，并进行相应的操作。</p>
<p>不同的软件开发阶段涉及的自动化测试技术为主线，包括单元测试、代码级集成测试、Web Service 测试和 GUI 测试</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试本身就是自动化的，它根据软件详细设计采用等价类划分和边界值分析方法设计测试用例，在测试代码实现后再以自动化的方式统一执行。<br>但从广义讲，单元测试阶段的“自动化”内涵不仅仅指测试用例执行的自动化，还应该包含以下五个方面：</p>
<ol>
<li><p>用例框架代码生成的自动化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">有些框架代码应该由自动化工具生成，而不是由开发者手工完成。</span><br><span class="line">TestNG 框架代码应该由自动化工具生成</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分测试输入数据的自动化生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">某个被测函数的原型是 void fun（int* p, short b），那么测试数据自动生成技术就会为输入参数 int* p 自动生成“空”和“非空”的两个指针 p，</span><br><span class="line">然后分别执行函数 void fun（int* p, short b），并观察函数的执行情况。</span><br><span class="line">如果函数内部没有对空指针进行特殊处理，那么函数 fun 的调用必定会抛出异常，发现函数的设计缺陷。</span><br><span class="line">同样地，对于输入参数 short b 会自动生成超出 short 范围的b，测试函数 fun 的行为。</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动桩代码的生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">自动桩代码的生成是指自动化工具可以对被测试代码进行扫描分析，自动为被测函数内部调用的其他函数生成可编程的桩代码，并提供基于测试用例的桩代码管理机制。</span><br><span class="line">此时，单元测试开发者只需重点关注桩代码内的具体逻辑实现，以及桩代码的返回值。</span><br><span class="line">必要的时候，自动化工具还需要实现 “抽桩”，以适应后续的代码级集成测试的需求。</span><br><span class="line">“抽桩”指 在单元测试阶段，假如函数 A 内部调用的函数 B 是桩代码，那么在代码级集成测试阶段，我们希望函数 A 不再调用假的函数 B，而是调用真实的函数 B，这个用真实函数 B 代替原本桩代码函数 B 的操作，就称为“抽桩”。</span><br></pre></td></tr></table></figure>
</li>
<li><p>被测代码的自动化静态分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态分析主要指代码的静态扫描，识别出违反编码规则或编码风格的代码行。</span><br><span class="line">通常这部分工作是结合项目具体的编码规则和编码风格，由自动化工具通过内建规则和用户自定义规则自动化完成的。</span><br><span class="line">目前比较常用的代码静态分析工具有 Sonar 和 Coverity 等。</span><br><span class="line">严格意义上讲，静态分析不属于单元测试的范畴，但这部分工作一般是在单元测试阶段通过自动化工具完成的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试覆盖率的自动统计与分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单元测试用例执行结束后，自动化工具可以自动统计各种测试覆盖率，包括代码行覆盖率、分支覆盖率、MC/DC 覆盖率等。</span><br><span class="line">这些自动统计的指标，可以衡量单元测试用例集合的充分性和完备性，并可以提供适当增补测试用例以提高测试覆盖率的依据。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="代码级集成测试的自动化技术"><a href="#代码级集成测试的自动化技术" class="headerlink" title="代码级集成测试的自动化技术"></a>代码级集成测试的自动化技术</h3><p>代码级集成测试是指将已经开发完成的软件模块放在一起测试。关注点更多的是软件模块之间的接口调用和数据传递。</p>
<ol>
<li>代码级集成测试，被测函数内部调用的其他函数必须是真实的，不允许使用桩代码代替，而单元测试中允许使用桩代码来模拟内部调用的其他函数。</li>
<li>代码级集成测试对测试框架的要求非常高，这个框架除了可以顺利装载自己的软件模块外，还必须能装载其他相互依赖的模块，做到被测软件模块可运行（Runnable）。</li>
<li>代码级集成测试主要应用在早期非互联网的传统软件企业，那时候的软件以“单体”应用居多，一个软件内部包含大量的功能，每一个软件功能都是通过不同的内部模块来实现的，这些内部模块在做集成的时候，就需要做代码级集成测试。</li>
</ol>
<h3 id="Web-Service-测试的自动化技术"><a href="#Web-Service-测试的自动化技术" class="headerlink" title="Web Service 测试的自动化技术"></a>Web Service 测试的自动化技术</h3><p>Web Service 测试，主要是指 SOAP API 和 REST API 这两类 API 测试。</p>
<h4 id="对于基于代码的-API-测试用例，通常包含三大步骤："><a href="#对于基于代码的-API-测试用例，通常包含三大步骤：" class="headerlink" title="对于基于代码的 API 测试用例，通常包含三大步骤："></a>对于基于代码的 API 测试用例，通常包含三大步骤：</h4><ul>
<li>准备 API 调用时需要的测试数据；</li>
<li>准备 API 的调用参数并发起 API 的调用；</li>
<li>验证 API 调用的返回结果。</li>
</ul>
<h4 id="流行的API-自动测试框架是-REST-Assured"><a href="#流行的API-自动测试框架是-REST-Assured" class="headerlink" title="流行的API 自动测试框架是 REST Assured"></a>流行的API 自动测试框架是 REST Assured</h4><p>  它可以方便地发起 Restful API 调用并验证返回结果。</p>
<h4 id="Web-Service-测试“自动化”的内涵不仅仅包括-API-测试用例执行的自动化，还包括以下四个方面："><a href="#Web-Service-测试“自动化”的内涵不仅仅包括-API-测试用例执行的自动化，还包括以下四个方面：" class="headerlink" title="Web Service 测试“自动化”的内涵不仅仅包括 API 测试用例执行的自动化，还包括以下四个方面："></a>Web Service 测试“自动化”的内涵不仅仅包括 API 测试用例执行的自动化，还包括以下四个方面：</h4><ul>
<li><p>测试脚手架代码的自动化生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">测试脚手架代码的自动生成技术，它生成的测试脚手架代码，通常包含了被测试 API 的调用、测试数据与脚本的分离，以及 Response 验证的空实现。</span><br></pre></td></tr></table></figure>
</li>
<li><p>部分测试输入数据的自动生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">API 测试对应的输入数据是 API 的参数以及 API 调用的 Payload。数据生成的原则同样遵循边界值原则。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Response 验证的自动化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于 API 调用返回结果的验证，通常关注的点是返回状态码（status code）、Scheme 结构以及具体的字段值。</span><br><span class="line">Response 验证自动化的核心思想是自动比较两次相同 API 调用的返回结果，并自动识别出有差异的字段值，比较过程可以通过规则配置去掉诸如时间戳、会话 ID（Session ID）等动态值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于 SoapUI 或者 Postman 的自动化脚本生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开发一个自动化代码转换生成工具。这个工具的输入是 SoapUI 或者 Postman 的测试用例元数据（即测试用例的 JSON 元文件），输出是符合 API 测试框架规范的基于代码实现的测试用例。</span><br><span class="line">这样一来，原本的测试用例积累可以直接转换成在 CI/CD 上可以直接接入的自动化测试用例。</span><br><span class="line">对于新的测试用例，还可以继续用 SoapUI 或者 Postman 做初步的测试验证，初步验证没有问题后，直接转换成符合 API 测试框架规范的测试用例。对于复杂的测试用例，也可以直接基于代码来实现，而且灵活性会更好。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="GUI-测试的自动化技术"><a href="#GUI-测试的自动化技术" class="headerlink" title="GUI 测试的自动化技术"></a>GUI 测试的自动化技术</h3><ol>
<li><p>GUI 测试核心思想是，基于页面元素识别技术，对页面元素进行自动化操作，以模拟实际终端用户的行为并验证软件功能的正确性。</p>
</li>
<li><p>目前，GUI 自动化测试主要分为两大方向，传统 Web 浏览器和移动端原生应用（Native App）的 GUI 自动化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于传统 Web 浏览器的 GUI 自动化测试，业内主流的开源方案采用 Selenium，商业方案采用 Micro Focus 的 UFT（前身是 HP 的 QTP）；</span><br><span class="line">对于移动端原生应用，通常采用主流的 Appium，它对 iOS 环境集成了 XCUITest，对 Android 环境集成了 UIAutomator 和 Espresso。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/10275" target="_blank" rel="noopener">https://time.geekbang.org/column/article/10275</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/软件测试4——是否需要自动化测试？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/软件测试4——是否需要自动化测试？/" itemprop="url">软件测试4——自动化测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-15T20:47:11+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><blockquote>
<p>最常见的 GUI 自动化测试来讲，就是由自动化测试工具模拟之前需要人工在软件界面上的各种操作，并且自动验证其结果是否符合预期。</p>
</blockquote>
<h3 id="自动化测试优势："><a href="#自动化测试优势：" class="headerlink" title="自动化测试优势："></a>自动化测试优势：</h3><ul>
<li>自动化测试可以替代大量的手工机械重复性操作，测试工程师可以把更多的时间花在更全面的用例设计和新功能的测试上；</li>
<li>自动化测试可以大幅提升回归测试的效率，非常适合敏捷开发过程；</li>
<li>自动化测试可以更好地利用无人值守时间，去更频繁地执行测试，适合现在非工作时间执行测试，工作时间分析失败用例的工作模式；</li>
<li>自动化测试可以高效实现某些手工测试无法完成或者代价巨大的测试类型，比如关键业务 7×24 小时持续运行的系统稳定性测试和高并发场景的压力测试等；</li>
<li>自动化测试还可以保证每次测试执行的操作以及验证的一致性和可重复性，避免人为的遗漏或疏忽。</li>
</ul>
<h3 id="自动化测试劣势："><a href="#自动化测试劣势：" class="headerlink" title="自动化测试劣势："></a>自动化测试劣势：</h3><ul>
<li>自动化测试并不能取代手工测试，它只能替代手工测试中执行频率高、机械化的重复步骤。</li>
<li>自动测试远比手动测试脆弱，无法应对被测系统的变化。其根本原因在于自动化测试本身不具有任何“智能”，只是按部就班地执行事先定义好的测试步骤并验证测试结果。对于执行过程中出现的明显错误和意外事件，自动化测试没有任何处理能力。</li>
<li>自动化测试用例的开发工作量远大于单次的手工测试，所以只有当开发完成的测试用例的有效执行次数大于等于 5 次时，才能收回自动化测试的成本。</li>
<li>手工测试发现的缺陷数量通常比自动化测试要更多，并且自动化测试仅仅能发现回归测试范围的缺陷。</li>
<li>测试的效率很大程度上依赖自动化测试用例的设计以及实现质量，不稳定的自动化测试用例实现比没有自动化更糟糕。</li>
</ul>
<p>业务测试专家和自动化测试专家通常是两批人，前者懂业务不懂自动化技术，后者懂自动化技术但不懂业务，只有二者紧密合作，才能高效开展自动化测试。</p>
<h3 id="什么样的项目适合自动化测试？"><a href="#什么样的项目适合自动化测试？" class="headerlink" title="什么样的项目适合自动化测试？"></a>什么样的项目适合自动化测试？</h3><ol>
<li><p>需求稳定，不会频繁变更。<br>过高的需求变更频率会导致自动化测试用例的维护成本直线上升。</p>
</li>
<li><p>研发和维护周期长，需要频繁执行回归测试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 软件产品比软件项目更适合做自动化测试。</span><br><span class="line">- 而对于一些中长期项目，对比较稳定的软件功能进行自动化测试，对变动较大或者需求暂时不明确的功能进行手工测试，最终目标是用 20%的精力去覆盖 80%的回归测试。</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要在多种平台上重复运行相同测试的场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 对于 GUI 测试，同样的测试用例需要在多种不同的浏览器上执行；</span><br><span class="line">- 对于移动端应用测试，同样的测试用例需要在多个不同的 Android 或者 iOS 版本上执行，或者是同样的测试需要在大量不同的移动终端上执行；</span><br><span class="line">- 对于一些企业级软件，如果对于不同的客户有不同的定制版本，各个定制版本的主体功能绝大多数是一致的，可能只有个别功能有轻微差别，测试也是需要覆盖每个定制版本的所有测试；</span><br></pre></td></tr></table></figure>
</li>
<li><p>某些测试项目通过手工测试无法实现，或者手工成本太高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 某一个项目要求进行一万并发用户的基准性能测试（Benchmark test）</span><br><span class="line">- 对于 7×24 小时的稳定性测试</span><br><span class="line">- 用机器来模拟大量用户反复操作被测软件的场景。此类测试是不可能通过 GUI 操作来模拟大量用户行为的，必须基于协议的自动化测试技术。</span><br></pre></td></tr></table></figure>
</li>
<li><p>被测软件的开发较为规范，能够保证系统的可测试性。</p>
</li>
</ol>
<blockquote>
<p>如果要实现稳定的自动化测试，被测软件的开发过程就必须规范。比如，GUI 上的控件命名如果没有任何规则可寻，就会造成 GUI 自动化的控件识别与定位不稳定，从而影响自动化测试的效率。<br>另外，某些用例的自动化必须要求开发人员在产品中预留可测试性接口，否则后续的自动化会很难开展。<br>比如，有些用户登录操作，需要图片验证码，如果开发人员没有提供绕开图片验证码的路径，那么自动化测试就必须借助光学字符识别（OCR）技术来对图片验证码进行模式识别，而它的设计初衷是为了防止机器人操作，可想而知 OCR 的识别率会很低，就会直接影响用例的稳定性。</p>
</blockquote>
<hr>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/10275" target="_blank" rel="noopener">https://time.geekbang.org/column/article/10275</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/14/软件测试3——什么是单元测试？如何做好单元测试？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/14/软件测试3——什么是单元测试？如何做好单元测试？/" itemprop="url">软件测试3——做好单元测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-14T19:49:36+08:00">
                2018-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><ul>
<li>单元测试是指，对软件中的最小可测试单元在与程序其他部分相隔离的情况下进行检查和验证的工作，这里的最小可测试单元通常是指函数或者类。</li>
<li>单元测试的实施过程还可以帮助开发工程师改善代码的设计与实现，并能在单元测试代码里提供函数的使用示例，因为单元测试的具体表现形式就是对函数以各种不同输入参数组合进行调用，这些调用方法构成了函数的使用说明。</li>
</ul>
<h3 id="如何做好单元测试？"><a href="#如何做好单元测试？" class="headerlink" title="如何做好单元测试？"></a>如何做好单元测试？</h3><pre><code>先弄清楚单元测试的对象是代码，以及代码的基本特征和产生错误的原因，掌握什么是驱动代码、桩代码和 Mock 代码等。
</code></pre><h4 id="代码的基本特征与产生错误的原因"><a href="#代码的基本特征与产生错误的原因" class="headerlink" title="代码的基本特征与产生错误的原因"></a>代码的基本特征与产生错误的原因</h4><p>因为无论是开发语言还是脚本语言，都会有条件分支、循环处理和函数调用等最基本的逻辑控制。<br>仅看代码结构的话，你会发现所有的代码都是在对数据进行分类处理，每一次条件判定都是一次分类处理，嵌套的条件判定或者循环执行，也是在做分类处理。<br>要做到代码功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确。</p>
<ul>
<li>在具体的工程实践中，开发工程师为了设计并实现逻辑功能正确的代码，通常会有如下的考虑过程：</li>
<li>如果要实现正确的功能逻辑，会有哪几种正常的输入；是否有需要特殊处理的多种边界输入；各种潜在非法输入的可能性以及如何处理。</li>
<li>这些开发工程师眼中的代码“功能点”，就是单元测试的“等价类”。</li>
</ul>
<h4 id="单元测试用例详解"><a href="#单元测试用例详解" class="headerlink" title="单元测试用例详解"></a>单元测试用例详解</h4><blockquote>
<p>通常来讲，单元测试的用例是一个“输入数据”和“预计输出”的集合。</p>
</blockquote>
<h5 id="被测试函数的输入参数；"><a href="#被测试函数的输入参数；" class="headerlink" title="被测试函数的输入参数；"></a>被测试函数的输入参数；</h5><ul>
<li>被测试函数内部需要读取的全局静态变量；</li>
<li>被测试函数内部需要读取的成员变量；</li>
<li>函数内部调用子函数获得的数据；</li>
<li>函数内部调用子函数改写的数据；</li>
<li>嵌入式系统中，在中断调用时改写的数据；</li>
</ul>
<h5 id="“预计输出”-绝对不是只有函数返回值这么简单，还应该包括函数执行完成后所改写的所有数据。"><a href="#“预计输出”-绝对不是只有函数返回值这么简单，还应该包括函数执行完成后所改写的所有数据。" class="headerlink" title="“预计输出” 绝对不是只有函数返回值这么简单，还应该包括函数执行完成后所改写的所有数据。"></a>“预计输出” 绝对不是只有函数返回值这么简单，还应该包括函数执行完成后所改写的所有数据。</h5><ul>
<li>被测试函数的返回值；</li>
<li>被测试函数的输出参数；</li>
<li>被测试函数所改写的成员变量；</li>
<li>被测试函数所改写的全局变量；</li>
<li>被测试函数中进行的文件更新；</li>
<li>被测试函数中进行的数据库更新；</li>
<li>被测试函数中进行的消息队列更新；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另外，对于预计输出值，你必须严格根据代码的功能逻辑来设定，而不能通过阅读代码来推算预期输出。</span><br><span class="line">最后，如果某些等价类或者边界值，开发工程师在开发的时候都没有考虑到，测试的时候就更不会去设计对应的测试用例了，这样也就会造成测试盲区。</span><br></pre></td></tr></table></figure>
<h4 id="驱动代码，桩代码和-Mock-代码"><a href="#驱动代码，桩代码和-Mock-代码" class="headerlink" title="驱动代码，桩代码和 Mock 代码"></a>驱动代码，桩代码和 Mock 代码</h4><pre><code>驱动代码是用来调用被测函数的，而桩代码和 Mock 代码是用来代替被测函数调用的真实代码的。
</code></pre><h5 id="驱动代码，桩代码和-Mock-代码三者的逻辑关系"><a href="#驱动代码，桩代码和-Mock-代码三者的逻辑关系" class="headerlink" title="驱动代码，桩代码和 Mock 代码三者的逻辑关系:"></a>驱动代码，桩代码和 Mock 代码三者的逻辑关系:</h5><p>   <img src="/2018/07/14/软件测试3——什么是单元测试？如何做好单元测试？/unit1.jpeg" alt="三者关系"></p>
<ul>
<li>驱动代码（Driver）指调用被测函数的代码，模拟请求去调用被测试的函数。在单元测试过程中，驱动模块通常包括调用被测函数前的数据准备、调用被测函数以及验证相关结果三个步骤。驱动代码的结构，通常由单元测试的框架决定。</li>
<li>桩代码（Stub）是用来代替真实代码的临时代码。 比如，某个函数 A 的内部实现中调用了一个尚未实现的函数 B，为了对函数 A 的逻辑进行测试，那么就需要模拟一个函数 B，这个模拟的函数 B 的实现就是所谓的桩代码。</li>
</ul>
<blockquote>
<p>例子：假定函数 A 是被测函数，其内部调用了函数 B：<br>在单元测试阶段，由于函数 B 尚未实现，但是为了不影响对函数 A 自身实现逻辑的测试，你可以用一个假的函数 B 来代替真实的函数 B，那么这个假的函数 B 就是桩函数。<br>为了实现函数 A 的全路径覆盖，你需要控制不同的测试用例中函数 B 的返回值。</p>
</blockquote>
<h5 id="桩函数内部实现"><a href="#桩函数内部实现" class="headerlink" title="桩函数内部实现"></a>桩函数内部实现</h5><p>桩代码的应用首先起到了隔离和补齐的作用，使被测代码能够独立编译、链接，并独立运行。同时，桩代码还具有控制被测函数执行路径的作用。</p>
<p>编写桩代码通常需要遵守以下三个原则：</p>
<ul>
<li>桩函数要具有与原函数完全相同的原形，仅仅是内部实现不同，这样测试代码才能正确链接到桩函数；</li>
<li>用于实现隔离和补齐的桩函数比较简单，只需保持原函数的声明，加一个空的实现，目的是通过编译链接；</li>
<li>实现控制功能的桩函数是应用最广泛的，要根据测试用例的需要，输出合适的数据作为被测函数的内部输入。</li>
</ul>
<h5 id="Mock-代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。"><a href="#Mock-代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。" class="headerlink" title="Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。"></a>Mock 代码和桩代码非常类似，都是用来代替真实代码的临时代码，起到隔离和补齐的作用。</h5><blockquote>
<p>在我看来，Mock 代码和桩代码的本质区别是：测试期待结果的验证（Assert and Expectiation）。<br>对于 Mock 代码来说，关注点是 Mock 方法有没有被调用，以什么样的参数被调用，被调用的次数，以及多个 Mock 函数的先后调用顺序。所以，在使用 Mock 代码的测试中，对于结果的验证，通常出现在 Mock 函数中。<br>对于桩代码来说，关注点是利用 Stub 来控制被测函数的执行路径，不会去关注 Stub 是否被调用以及怎么样被调用。所以，你在使用 Stub 的测试中，对于结果的验证，通常出现在驱动代码中。</p>
</blockquote>
<h3 id="实际项目中如何开展单元测试？"><a href="#实际项目中如何开展单元测试？" class="headerlink" title="实际项目中如何开展单元测试？"></a>实际项目中如何开展单元测试？</h3><p>并不是所有的代码都要进行单元测试，通常只有底层模块或者核心模块的测试中才会采用单元测试。</p>
<ul>
<li>你需要确定单元测试框架的选型，这和开发语言直接相关。比如，Java 最常用的单元测试框架是 Junit 和 TestNG；C/C++ 最常用的单元测试框架是 CppTest 和 Parasoft C/C++test；框架选型完成后，你还需要对桩代码框架和 Mock 代码框架选型。</li>
<li>为了能够衡量单元测试的代码覆盖率，通常你还需要引入计算代码覆盖率的工具。不同的语言会有不同的代码覆盖率统计工具，比如 Java 的 JaCoCo，JavaScript 的 Istanbul。</li>
<li>最后你需要把单元测试执行、代码覆盖率统计和持续集成流水线做集成，以确保每次代码递交，都会自动触发单元测试，并在单元测试执行过程中自动统计代码覆盖率，最后以“单元测试通过率”和“代码覆盖率”为标准来决定本次代码递交是否能够被接受。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">真正在项目中全面推行单元测试时，还有一些困难需要克服：</span><br><span class="line">紧密耦合的代码难以隔离；</span><br><span class="line">隔离后编译链接运行困难；</span><br><span class="line">代码本身的可测试性较差，通常代码的可测试性和代码规模成正比；</span><br><span class="line">无法通过桩代码直接模拟系统底层函数的调用；</span><br><span class="line">代码覆盖率越往后越难提高。</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>代码要做到功能逻辑正确，必须做到分类正确并且完备无遗漏，同时每个分类的处理逻辑必须正确；</li>
<li>单元测试是对软件中的最小可测试单元在与软件其他部分相隔离的情况下进行的代码级测试；</li>
<li>桩代码起到了隔离和补齐的作用，使被测代码能够独立编译、链接，并运行。</li>
</ol>
<hr>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/10275" target="_blank" rel="noopener">https://time.geekbang.org/column/article/10275</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/08/软件测试2——如何设计一个好的测试用例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kingvirre">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/blog-logo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kingvirre">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/软件测试2——如何设计一个好的测试用例/" itemprop="url">软件测试2——设计一个好的测试用例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-08T20:18:32+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="好的测试用例"><a href="#好的测试用例" class="headerlink" title="好的测试用例"></a>好的测试用例</h2><p>“好的”测试用例一定是一个完备的集合，它能够覆盖所有等价类以及各种边界值，而跟能否发现缺陷无关。</p>
<h3 id="好的测试用例特征"><a href="#好的测试用例特征" class="headerlink" title="好的测试用例特征"></a>好的测试用例特征</h3><ol>
<li>整体完备性： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合，能够完全覆盖测试需求。</li>
<li>等价类划分的准确性： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。</li>
<li>等价类集合的完备性： 需要保证所有可能的边界值和边界条件都已经正确识别。</li>
</ol>
<h3 id="如何设计好的测试用例"><a href="#如何设计好的测试用例" class="headerlink" title="如何设计好的测试用例"></a>如何设计好的测试用例</h3><ol>
<li>等价类划分方法</li>
</ol>
<blockquote>
<p>例子：学生信息系统中有一个“考试成绩”的输入项，成绩的取值范围是 0~100 之间的整数，考试成绩及格的分数线是 60。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 有效等价类 1：0~59 之间的任意整数；</span><br><span class="line">- 有效等价类 2：59~100 之间的任意整数；</span><br><span class="line">- 无效等价类 1：小于 0 的负数；</span><br><span class="line">- 无效等价类 2：大于 100 的整数；</span><br><span class="line">- 无效等价类 3：0~100 之间的任何浮点数；</span><br><span class="line">- 无效等价类 4：其他任意非数字字符。</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li><p>边界值分析方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 通常选取正好等于、刚刚大于或刚刚小于边界的值作为测试数据。</span><br><span class="line">- 我们继续看学生信息系统中“考试成绩”的例子，选取的边界值数据应该包括：-1，0，1，59，60，61，99，100，101。</span><br></pre></td></tr></table></figure>
</li>
<li><p>错误推测方法</p>
</li>
</ol>
<blockquote>
<p>比如，Web 界面的 GUI 功能测试，需要考虑浏览器在有缓存和没有缓存下的表现；Web Service 的 API 测试，<br>需要考虑被测 API 所依赖的第三方 API 出错下的处理逻辑；<br>对于代码级的单元测试，需要考虑被测函数的输入参数为空情况下的内部处理逻辑等等。</p>
</blockquote>
<h3 id="“好的”测试用例？"><a href="#“好的”测试用例？" class="headerlink" title="“好的”测试用例？"></a>“好的”测试用例？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面向终端用户的 GUI 测试为例</span><br><span class="line">面向终端用户的 GUI 测试，最核心的测试点就是验证软件对需求的满足程度，这就要求测试工程师对被测软件的需求有深入的理解。</span><br><span class="line">在具体的用例设计时，首先需要搞清楚每一个业务需求所对应的多个软件功能需求e点，然后分析出每个软件功能需求点对应的多个测试需求点，最后再针对每个测试需求点设计测试用例。</span><br></pre></td></tr></table></figure>
<p><img src="/2018/07/08/软件测试2——如何设计一个好的测试用例/2.jpeg" alt=""></p>
<p>图中的业务需求——软件功能需求——测试需求——测试用例的映射关系.</p>
<ol>
<li>从软件功能需求出发，全面地、无遗漏地识别出测试需求是至关重要的，这将直接关系到用例的测试覆盖率。<blockquote>
<p>比如，如果你没有识别出用户登录功能的安全性测试需求，那么后续设计的测试用例就完全不会涉及安全性，最终造成重要测试漏洞。</p>
</blockquote>
</li>
<li>对于识别出的每个测试需求点，需要综合运用等价类划分、边界值分析和错误推测方法来全面地设计测试用例。</li>
</ol>
<blockquote>
<p>作为测试工程师，切忌不能把整个被测系统看作一个大黑盒，你必须对内部的架构有清楚的认识，比如数据库连接方式、数据库的读写分离、消息中间件 Kafka 的配置、缓存系统的层级分布、第三方系统的集成等等。<br>如果想设计一个“好的”测试用例，你必须要深入理解被测软件的架构设计，深入软件内部的处理逻辑，需求覆盖率和代码覆盖率这两个指标可以帮你衡量测试执行的完备性。</p>
</blockquote>
<hr>
<p>极客时间版权所有: <a href="https://time.geekbang.org/column/article/10275" target="_blank" rel="noopener">https://time.geekbang.org/column/article/10275</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/blog-logo.jpg"
                alt="Kingvirre" />
            
              <p class="site-author-name" itemprop="name">Kingvirre</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">

&copy; 
<span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kingvirre</span>
</div>

  <div class="powered-by">
  <i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv"> <span id="busuanzi_value_site_uv"></span></span>
  </div>

  <div class="theme-info">
  访客量 &mdash;
  </div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
